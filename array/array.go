package array

import (
	"fmt"
	"math/rand"
)

// Merge any number of slices into a slice
func Merge[T any](ss ...[]T) []T {
	var result []T
	for _, s := range ss {
		result = append(result, s...)
	}
	return result
}

// Split a slice into multiple slices, which
// The n determines the number of slice to return
// n > 0: at most n sub slices; the last sub slice will be the unsplit remainder.
// n <= 0: the result is nil

func Chunk[T any](s []T, n int) [][]T {
	if n <= 0 {
		return nil
	}

	var chunks [][]T
	for i := 0; i < len(s); i += n {
		end := i + n
		if end > len(s) {
			end = len(s)
		}
		chunks = append(chunks, s[i:end])
	}
	return chunks
}

// Pad Add padding of given size to fill the slice, with the specified value val
func Pad[T any](s []T, size int, val T) []T {
	if size > 0 {
		for i := len(s); i < size; i++ {
			s = append(s, val)
		}
	} else if size < 0 {
		for i := len(s); i < -size; i++ {
			s = append([]T{val}, s...)
		}
	}
	return s
}

// A new slice is generated by randomly taking n elements from the original slice
func Rand[T any](s []T, n int) []T {
	if n <= 0 || n > len(s) {
		return nil
	}

	rand.Shuffle(len(s), func(i, j int) { s[i], s[j] = s[j], s[i] })

	return s[:n]
}

// Column 从元素为map的切片中，找到所有map指定的key对应的value值，并返回切片
func Column[T any, K comparable](maps []map[K]T, key K) []T {
	var column []T
	for _, m := range maps {
		if val, ok := m[key]; ok {
			column = append(column, val)
		}
	}
	return column
}

// Implode 将任意类型数组，按照分割符，转成字符串
func Implode[T any](arr []T, delimiter string) string {
	var result string
	for i, v := range arr {
		if i > 0 {
			result += delimiter
		}
		result += fmt.Sprintf("%v", v)
	}

	return result
}
